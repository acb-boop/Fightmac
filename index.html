<!DOCTYPE html>
<html>
<head>
    <title>Bouncing Squares with Audio Recording</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
            font-family: Arial, sans-serif;
            padding: 20px;
        }
        #container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        #canvas-wrapper {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .health-bars {
            display: flex;
            gap: 20px;
            margin-bottom: 10px;
        }
        .health-bar {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }
        .health-bar-container {
            width: 180px;
            height: 20px;
            border: 2px solid #333;
            background-color: #ddd;
            display: flex;
            border-radius: 4px;
            overflow: hidden;
        }
        .health-segment {
            flex: 1;
            height: 100%;
            border-right: 1px solid #333;
            transition: background-color 0.3s ease;
        }
        .health-segment:last-child {
            border-right: none;
        }
        .health-bar-label {
            font-size: 12px;
            font-weight: bold;
            color: #333;
        }
        canvas {
            border: 2px solid #333;
            background-color: white;
            -webkit-user-select: none;
            user-select: none;
        }
        .controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .recorder-controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
            padding: 15px;
            background-color: #e8e8e8;
            border-radius: 8px;
            border: 2px solid #ccc;
        }
        .recorder-status {
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: bold;
        }
        .recording-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: #ccc;
        }
        .recording-indicator.active {
            background-color: #e74c3c;
            -webkit-animation: pulse 1s infinite;
            animation: pulse 1s infinite;
        }
        @-webkit-keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        button {
            padding: 8px 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        button:hover {
            background-color: #45a049;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        .record-btn {
            background-color: #e74c3c;
        }
        .record-btn:hover {
            background-color: #c0392b;
        }
        .stop-btn {
            background-color: #34495e;
        }
        .stop-btn:hover {
            background-color: #2c3e50;
        }
        .download-btn {
            background-color: #3498db;
        }
        .download-btn:hover {
            background-color: #2980b9;
        }
        .restore-btn {
            background-color: #9b59b6;
        }
        .restore-btn:hover {
            background-color: #8e44ad;
        }
        .sound-btn {
            background-color: #f39c12;
        }
        .sound-btn:hover {
            background-color: #e67e22;
        }
        .color-picker {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }
        .health-color-controls {
            display: flex;
            gap: 20px;
            margin-top: 10px;
            justify-content: center;
        }
        .health-color-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }
        .background-color-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
            padding: 10px;
            background-color: #f9f9f9;
            border-radius: 8px;
            border: 1px solid #ddd;
        }
        label {
            font-weight: bold;
        }
        .color-input {
            padding: 4px;
            border: 1px solid #ccc;
            border-radius: 4px;
            width: 80px;
            text-align: center;
        }
        .color-picker-input {
            width: 50px;
            height: 30px;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 0;
            cursor: pointer;
        }
        .recorder-info {
            font-size: 12px;
            color: #666;
            text-align: center;
            margin-top: 5px;
        }
        .frame-color-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
            padding: 10px;
            background-color: #f9f9f9;
            border-radius: 8px;
            border: 1px solid #ddd;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="canvas-wrapper">
            <div class="health-bars">
                <div class="health-bar">
                    <div class="health-bar-label">Blue Square</div>
                    <div class="health-bar-container" id="blueHealthBar">
                        <div class="health-segment"></div>
                        <div class="health-segment"></div>
                        <div class="health-segment"></div>
                        <div class="health-segment"></div>
                    </div>
                </div>
                <div class="health-bar">
                    <div class="health-bar-label">Red Square</div>
                    <div class="health-bar-container" id="redHealthBar">
                        <div class="health-segment"></div>
                        <div class="health-segment"></div>
                        <div class="health-segment"></div>
                        <div class="health-segment"></div>
                    </div>
                </div>
            </div>
            <canvas id="canvas" width="1080" height="720"></canvas>
        </div>
        
        <!-- Screen Recorder Controls -->
        <div class="recorder-controls">
            <div class="recorder-status">
                <div class="recording-indicator" id="recordingIndicator"></div>
                <span id="recordingStatus">Ready to Record</span>
            </div>
            <button id="startRecordBtn" class="record-btn">Start Recording</button>
            <button id="stopRecordBtn" class="stop-btn" disabled>Stop Recording</button>
            <button id="downloadBtn" class="download-btn" disabled>Download Video</button>
            <div class="recorder-info">
                Records at 30fps in 1080p resolution with audio
            </div>
        </div>
        
        <!-- Background Color Control -->
        <div class="background-color-control">
            <label for="backgroundColorText">Canvas Background Color:</label>
            <input type="text" id="backgroundColorText" class="color-input" value="#ffffff" placeholder="#RRGGBB">
            <input type="color" id="backgroundColorPicker" class="color-picker-input" value="#ffffff">
            <button id="applyBackgroundBtn">Apply</button>
            <button id="restoreBackgroundBtn" class="restore-btn">Restore Previous</button>
            <button id="toggleSoundBtn" class="sound-btn">Sound: ON</button>
        </div>
        
        <!-- Frame Color Control -->
        <div class="frame-color-control">
            <label for="frameColorText">Collision Frame Color:</label>
            <input type="text" id="frameColorText" class="color-input" value="#00ff00" placeholder="#RRGGBB">
            <input type="color" id="frameColorPicker" class="color-picker-input" value="#00ff00">
            <button id="applyFrameBtn">Apply</button>
            <button id="resetFrameBtn">Reset Frame</button>
        </div>
        
        <div class="controls">
            <button id="resetBtn">Reset</button>
            <button id="pauseBtn">Pause</button>
            <button id="speedBtn">Speed: 1x</button>
        </div>
        <div class="health-color-controls">
            <div class="health-color-group">
                <label for="redHealthColor">Red Health Bar Color:</label>
                <input type="text" id="redHealthColor" class="color-input" value="#e74c3c" placeholder="#RRGGBB">
            </div>
            <div class="health-color-group">
                <label for="blueHealthColor">Blue Health Bar Color:</label>
                <input type="text" id="blueHealthColor" class="color-input" value="#3498db" placeholder="#RRGGBB">
            </div>
        </div>
        <div class="color-picker">
            <label for="redThornColor">Red Square Thorn Color:</label>
            <input type="text" id="redThornColor" class="color-input" value="#BEBEBE" placeholder="#RRGGBB">
        </div>
        <div class="color-picker">
            <label for="blueThornColor">Blue Square Thorn Color:</label>
            <input type="text" id="blueThornColor" class="color-input" value="#BEBEBE" placeholder="#RRGGBB">
        </div>
    </div>

    <!-- Audio elements -->
    <audio id="redSound" src="red.wav" preload="auto"></audio>
    <audio id="blueSound" src="blue.wav" preload="auto"></audio>
    <audio id="hitSound" src="hit.wav" preload="auto"></audio>
    <audio id="knifeSound" src="knife.wav" preload="auto"></audio>
    <audio id="healSound" src="heal.wav" preload="auto"></audio>

    <script>
        // Get the canvas and its context
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { alpha: false }); // Disable alpha for better performance
        
        // Audio context variables
        let audioContext = null;
        let audioDestination = null;
        let audioSources = {};
        let audioInitialized = false;
        
        // Buttons
        const resetBtn = document.getElementById('resetBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const speedBtn = document.getElementById('speedBtn');
        const redThornColorInput = document.getElementById('redThornColor');
        const blueThornColorInput = document.getElementById('blueThornColor');
        const redHealthColorInput = document.getElementById('redHealthColor');
        const blueHealthColorInput = document.getElementById('blueHealthColor');
        const toggleSoundBtn = document.getElementById('toggleSoundBtn');
        
        // Background color controls
        const backgroundColorText = document.getElementById('backgroundColorText');
        const backgroundColorPicker = document.getElementById('backgroundColorPicker');
        const applyBackgroundBtn = document.getElementById('applyBackgroundBtn');
        const restoreBackgroundBtn = document.getElementById('restoreBackgroundBtn');
        
        // Frame controls
        const frameColorText = document.getElementById('frameColorText');
        const frameColorPicker = document.getElementById('frameColorPicker');
        const applyFrameBtn = document.getElementById('applyFrameBtn');
        const resetFrameBtn = document.getElementById('resetFrameBtn');
        
        // Screen Recorder Elements
        const startRecordBtn = document.getElementById('startRecordBtn');
        const stopRecordBtn = document.getElementById('stopRecordBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const recordingIndicator = document.getElementById('recordingIndicator');
        const recordingStatus = document.getElementById('recordingStatus');
        
        // Audio elements
        const sounds = {
            red: document.getElementById('redSound'),
            blue: document.getElementById('blueSound'),
            hit: document.getElementById('hitSound'),
            knife: document.getElementById('knifeSound'),
            heal: document.getElementById('healSound')
        };
        
        // Recording variables
        let mediaRecorder = null;
        let recordedChunks = [];
        let isRecording = false;
        let originalUpdate = null;
        
        // Frame variables
        let frameBounds = {
            left: 20,
            right: canvas.width - 20,
            top: 20,
            bottom: canvas.height - 20
        };
        let frameColor = "#00ff00";
        let frameThickness = 8;
        const MIN_FRAME_SIZE = 100;
        
        // Health bar elements
        const redHealthBar = document.getElementById('redHealthBar');
        const blueHealthBar = document.getElementById('blueHealthBar');
        
        // Game settings
        let isPaused = false;
        let speedMultiplier = 1;
        let redThornColor = "#BEBEBE";
        let blueThornColor = "#BEBEBE";
        let redHealthColor = "#e74c3c";
        let blueHealthColor = "#3498db";
        let canvasBackgroundColor = "#ffffff";
        let oldBackgroundColor = canvasBackgroundColor;
        let soundEnabled = true;
        const SOUND_COOLDOWN = 300;
        
        // Health tracking
        let redSquareHealth = 4;
        let blueSquareHealth = 4;
        
        // Default square properties
        const DEFAULT_SQUARE_SIZE = 120;
        
        // Speed constant
        const SPEED = 6;
        
        // Image loading tracking
        let loadedImages = 0;
        const totalImages = 4;
        
        // Image objects with loading event listeners
        const redSquareImg = new Image();
        redSquareImg.src = "red.png";
        let redSquareImgLoaded = true;
        
        const blueSquareImg = new Image();
        blueSquareImg.src = "blue.png";
        let blueSquareImgLoaded = true;
        
        const knifeImg = new Image();
        knifeImg.src = "knife.png";
        let knifeImgLoaded = true;
        
        const healImg = new Image();
        healImg.src = "heal.png";
        let healImgLoaded = true;
        
        // Fallback colors for squares
        const RED_SQUARE_COLOR = '#e74c3c';
        const BLUE_SQUARE_COLOR = '#3498db';
        
        // Powerup properties
        const KNIFE_SPAWN_INTERVAL = 8000;
        const HEAL_SPAWN_INTERVAL = 15000;
        const THORN_DURATION = 7000;
        const POWER_UP_SIZE = 60;
        
        // Power-up spawn intervals
        let knifeSpawnInterval = null;
        let healSpawnInterval = null;
        
        // Animation frame tracking
        let animationId = null;

        // Initialize audio system
        async function initializeAudio() {
            if (audioInitialized) return true;
            
            try {
                // Audio context requires user interaction
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    audioDestination = audioContext.createMediaStreamDestination();
                    
                    // Connect each audio element to the destination
                    Object.keys(sounds).forEach(key => {
                        const audioElement = sounds[key];
                        const source = audioContext.createMediaElementSource(audioElement);
                        source.connect(audioDestination);
                        source.connect(audioContext.destination); // Also play through speakers
                        audioSources[key] = source;
                    });
                }
                
                if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                }
                
                audioInitialized = true;
                return true;
            } catch (error) {
                console.error("Audio initialization failed:", error);
                return false;
            }
        }
        
        // Initialize audio on first user interaction
        document.addEventListener('click', async function initAudioOnClick() {
            const success = await initializeAudio();
            if (success) {
                document.removeEventListener('click', initAudioOnClick);
            }
        }, { once: true });
        
        // Power-up spawn functions
        function spawnKnifePowerUp() {
            if (knifeImgLoaded && loadedImages === totalImages) {
                const pos = getRandomPosition();
                powerUps.push({
                    x: pos.x,
                    y: pos.y,
                    size: POWER_UP_SIZE,
                    type: 'knife',
                    img: knifeImg
                });
            }
        }
        
        function spawnHealPowerUp() {
            if (healImgLoaded && loadedImages === totalImages) {
                const pos = getRandomPosition();
                powerUps.push({
                    x: pos.x,
                    y: pos.y,
                    size: POWER_UP_SIZE,
                    type: 'heal',
                    img: healImg
                });
            }
        }
        
        // Sound functions
        async function playSound(soundName) {
            if (!soundEnabled) return;
            
            try {
                // Ensure audio is initialized and resumed
                if (!audioInitialized) {
                    const success = await initializeAudio();
                    if (!success) return;
                }
                
                const sound = sounds[soundName];
                if (sound) {
                    sound.currentTime = 0;
                    const playPromise = sound.play();
                    if (playPromise !== undefined) {
                        playPromise.catch(error => {
                            console.log("Sound play error:", error);
                        });
                    }
                }
            } catch (error) {
                console.error("Error playing sound:", error);
            }
        }
        
        async function playSquareSound(square) {
            if (!soundEnabled) return;
            
            const now = Date.now();
            if (now - square.lastPlayTime < SOUND_COOLDOWN) return;
            
            square.lastPlayTime = now;
            
            const soundName = square.isBlue ? 'blue' : 'red';
            await playSound(soundName);
        }
        
        // Toggle sound button
        toggleSoundBtn.addEventListener('click', function() {
            soundEnabled = !soundEnabled;
            toggleSoundBtn.textContent = soundEnabled ? 'Sound: ON' : 'Sound: OFF';
        });
        
        // Particle System
        class Particle {
            constructor(x, y, color = '#4ECDC4') {
                this.x = x;
                this.y = y;
                this.size = Math.random() * 6 + 2;
                this.speedX = (Math.random() - 0.5) * 8;
                this.speedY = (Math.random() - 0.5) * 8;
                this.life = 1;
                this.decay = Math.random() * 0.02 + 0.01;
                this.gravity = 0.1;
                this.bounce = 0.7;
                this.color = color;
            }
            
            update() {
                this.x += this.speedX;
                this.y += this.speedY;
                this.speedY += this.gravity;
                this.life -= this.decay;
                this.size *= 0.995;
                
                // Proper bounds checking
                if (this.y + this.size > canvas.height) {
                    this.y = canvas.height - this.size;
                    this.speedY *= -this.bounce;
                    this.speedX *= 0.9;
                }
                
                if (this.x + this.size > canvas.width || this.x - this.size < 0) {
                    this.speedX *= -this.bounce;
                    this.x = Math.max(this.size, Math.min(canvas.width - this.size, this.x));
                }
                
                return this.life > 0 && this.size > 0.1;
            }
            
            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        class ParticleSystem {
            constructor(canvas, options = {}) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.particles = [];
                
                this.options = {
                    color: options.color || '#4ECDC4',
                    particleCount: options.particleCount || 25,
                    autoFade: false,
                    ...options
                };
            }
            
            createExplosion(x, y, count = this.options.particleCount) {
                for (let i = 0; i < count; i++) {
                    const particle = new Particle(x, y, this.options.color);
                    this.particles.push(particle);
                }
            }
            
            update() {
                this.particles = this.particles.filter(particle => particle.update());
            }
            
            draw() {
                this.particles.forEach(particle => particle.draw(this.ctx));
            }
            
            animate() {
                this.update();
                this.draw();
            }
            
            clear() {
                this.particles = [];
            }
        }

        // Create particle systems for each square
        const redParticles = new ParticleSystem(canvas, { 
            color: redHealthColor, 
            particleCount: 30
        });
        const blueParticles = new ParticleSystem(canvas, { 
            color: blueHealthColor, 
            particleCount: 30
        });
        
        // Multi-color explosion function
        function createMultiColorExplosion(x, y) {
            const colors = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6', '#e67e22', '#1abc9c'];
            
            for (let i = 0; i < 50; i++) {
                const randomColor = colors[Math.floor(Math.random() * colors.length)];
                const particle = new Particle(x, y, randomColor);
                redParticles.particles.push(particle);
                blueParticles.particles.push(particle);
            }
            
            playSound('hit');
        }
        
        // Background color control functions
        function isValidHexColor(color) {
            return /^#([0-9A-F]{3}|[0-9A-F]{6})$/i.test(color);
        }
        
        function applyBackgroundColor(color) {
            if (isValidHexColor(color)) {
                oldBackgroundColor = canvasBackgroundColor;
                canvasBackgroundColor = color;
                canvas.style.backgroundColor = color;
                backgroundColorText.value = color;
                backgroundColorPicker.value = color;
            } else {
                alert("Invalid hex color format. Use #RRGGBB or #RGB");
            }
        }
        
        // Frame control functions
        function applyFrameColor(color) {
            if (isValidHexColor(color)) {
                frameColor = color;
                frameColorText.value = color;
                frameColorPicker.value = color;
            } else {
                alert("Invalid hex color format. Use #RRGGBB or #RGB");
            }
        }
        
        function resetFrame() {
            frameBounds = {
                left: 20,
                right: canvas.width - 20,
                top: 20,
                bottom: canvas.height - 20
            };
        }
        
        function shrinkFrame() {
            const shrinkAmount = 0.5; // Increased shrink amount for visible effect
            const newLeft = frameBounds.left + shrinkAmount;
            const newRight = frameBounds.right - shrinkAmount;
            const newTop = frameBounds.top + shrinkAmount;
            const newBottom = frameBounds.bottom - shrinkAmount;
            
            // Ensure minimum size
            if (newRight - newLeft >= MIN_FRAME_SIZE && newBottom - newTop >= MIN_FRAME_SIZE) {
                frameBounds.left = newLeft;
                frameBounds.right = newRight;
                frameBounds.top = newTop;
                frameBounds.bottom = newBottom;
            }
        }
        
        function drawCollisionFrame() {
            // Save current context state
            ctx.save();
            
            // Set up glow effect
            ctx.shadowColor = frameColor;
            ctx.shadowBlur = 8;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            
            // Draw the frame borders
            ctx.strokeStyle = frameColor;
            ctx.lineWidth = frameThickness;
            
            // Draw frame rectangle
            ctx.strokeRect(
                frameBounds.left, 
                frameBounds.top, 
                frameBounds.right - frameBounds.left, 
                frameBounds.bottom - frameBounds.top
            );
            
            // Draw inner glow effect
            ctx.shadowBlur = 4;
            ctx.strokeRect(
                frameBounds.left, 
                frameBounds.top, 
                frameBounds.right - frameBounds.left, 
                frameBounds.bottom - frameBounds.top
            );
            
            // Restore context state
            ctx.restore();
        }
        
        // Event listeners for background color controls
        applyBackgroundBtn.addEventListener('click', function() {
            const color = backgroundColorText.value;
            applyBackgroundColor(color);
        });
        
        backgroundColorPicker.addEventListener('input', function() {
            applyBackgroundColor(this.value);
        });
        
        backgroundColorPicker.addEventListener('change', function() {
            applyBackgroundColor(this.value);
        });
        
        backgroundColorText.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                applyBackgroundColor(this.value);
            }
        });
        
        // Restore background color button
        restoreBackgroundBtn.addEventListener('click', function() {
            applyBackgroundColor(oldBackgroundColor);
        });
        
        // Frame color controls
        applyFrameBtn.addEventListener('click', function() {
            applyFrameColor(frameColorText.value);
        });
        
        frameColorPicker.addEventListener('input', function() {
            applyFrameColor(this.value);
        });
        
        frameColorPicker.addEventListener('change', function() {
            applyFrameColor(this.value);
        });
        
        frameColorText.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                applyFrameColor(this.value);
            }
        });
        
        resetFrameBtn.addEventListener('click', resetFrame);
        
        // Modified getRandomPosition to spawn within frame bounds
        function getRandomPosition() {
            return {
                x: frameBounds.left + Math.random() * (frameBounds.right - frameBounds.left - POWER_UP_SIZE),
                y: frameBounds.top + Math.random() * (frameBounds.bottom - frameBounds.top - POWER_UP_SIZE)
            };
        }
        
        // Screen Recording Functions with Audio
        async function startRecording() {
            try {
                // Initialize audio if not already done
                if (!audioInitialized) {
                    const success = await initializeAudio();
                    if (!success) {
                        alert("Could not initialize audio. Please interact with the page first.");
                        return;
                    }
                }
                
                recordedChunks = [];
                
                // Create an off-screen canvas that matches the visible canvas size
                const recordingCanvas = document.createElement('canvas');
                recordingCanvas.width = canvas.width;
                recordingCanvas.height = canvas.height;
                const recordingCtx = recordingCanvas.getContext('2d');
                
                // Function to copy main canvas to recording canvas
                function copyToRecordingCanvas() {
                    // Clear with background color
                    recordingCtx.fillStyle = canvasBackgroundColor;
                    recordingCtx.fillRect(0, 0, recordingCanvas.width, recordingCanvas.height);
                    
                    // Copy the main canvas directly instead of redrawing
                    recordingCtx.drawImage(canvas, 0, 0);
                }
                
                // Store the original update function
                originalUpdate = update;
                
                // Override the main animation loop to also update recording canvas
                update = function() {
                    originalUpdate();
                    if (isRecording) {
                        copyToRecordingCanvas();
                    }
                };
                
                // Get canvas stream (lower framerate for Safari)
                const stream = recordingCanvas.captureStream(30);
                
                // Get audio stream
                const audioStream = audioDestination.stream;
                
                // Combine video and audio tracks
                const combinedStream = new MediaStream([
                    ...stream.getVideoTracks(),
                    ...audioStream.getAudioTracks()
                ]);
                
                // Set up MediaRecorder with Safari-compatible settings
                let options = { videoBitsPerSecond: 2500000 }; // Lower bitrate for Safari
                
                // Try different formats in order of preference
                const formats = [
                    'video/mp4', // Safari prefers MP4
                    'video/webm;codecs=vp9',
                    'video/webm;codecs=vp8', 
                    'video/webm'
                ];
                
                // Find the first supported format
                for (const format of formats) {
                    if (MediaRecorder.isTypeSupported(format)) {
                        options.mimeType = format;
                        break;
                    }
                }
                
                if (!options.mimeType) {
                    alert('Screen recording not supported in this browser');
                    return;
                }
                
                mediaRecorder = new MediaRecorder(combinedStream, options);
                
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        recordedChunks.push(event.data);
                    }
                };
                
                mediaRecorder.onstop = () => {
                    // Restore original update function
                    update = originalUpdate;
                    
                    const blob = new Blob(recordedChunks, { type: mediaRecorder.mimeType });
                    const url = URL.createObjectURL(blob);
                    
                    downloadBtn.disabled = false;
                    downloadBtn.onclick = () => {
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `bouncing-squares-${Date.now()}.${options.mimeType.includes('mp4') ? 'mp4' : 'webm'}`;
                        a.style.display = 'none';
                        document.body.appendChild(a);
                        a.click();
                        
                        // Clean up
                        setTimeout(() => {
                            document.body.removeChild(a);
                            URL.revokeObjectURL(url);
                        }, 100);
                    };
                    
                    recordingStatus.textContent = 'Recording Complete - Ready to Download';
                    recordingIndicator.classList.remove('active');
                };
                
                // Start recording
                mediaRecorder.start(100); // Collect data every 100ms
                isRecording = true;
                
                // Update UI
                startRecordBtn.disabled = true;
                stopRecordBtn.disabled = false;
                downloadBtn.disabled = true;
                recordingStatus.textContent = 'Recording...';
                recordingIndicator.classList.add('active');
                
            } catch (error) {
                console.error('Error starting recording:', error);
                alert('Error starting recording. Please make sure your browser supports canvas recording with audio.');
            }
        }
        
        function stopRecording() {
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
                isRecording = false;
                
                startRecordBtn.disabled = false;
                stopRecordBtn.disabled = true;
                recordingStatus.textContent = 'Processing...';
            }
        }
        
        // Event listeners for recording controls
        startRecordBtn.addEventListener('click', async function() {
            startRecording();
        });
        
        stopRecordBtn.addEventListener('click', stopRecording);
        
        // Function to update health bar display
        function updateHealthBar(healthBar, health, maxHealth, color) {
            const segments = healthBar.querySelectorAll('.health-segment');
            segments.forEach((segment, index) => {
                if (index < health) {
                    segment.style.backgroundColor = color;
                } else {
                    segment.style.backgroundColor = '#ddd';
                }
            });
        }
        
        // Function to calculate health based on square size
        function calculateHealth(size) {
            if (size <= 0) return 0;
            if (size >= 120) return 4;  // Full health
            if (size >= 90) return 3;   // 3/4 health
            if (size >= 60) return 2;   // 1/2 health
            if (size >= 30) return 1;   // 1/4 health
            return 0;                   // Dead
        }
        
        // Create squares with 45° angles only
        function createSquare(x, y, direction, color, imageSrc, isBlue = false) {
            let vx, vy;
            
            switch(direction) {
                case 0:
                    vx = SPEED;
                    vy = SPEED;
                    break;
                case 1:
                    vx = -SPEED;
                    vy = SPEED;
                    break;
                case 2:
                    vx = -SPEED;
                    vy = -SPEED;
                    break;
                case 3:
                    vx = SPEED;
                    vy = -SPEED;
                    break;
            }
            
            const img = isBlue ? blueSquareImg : redSquareImg;
            
            return {
                x,
                y,
                vx,
                vy,
                size: DEFAULT_SQUARE_SIZE,
                direction,
                color,
                img,
                hasThorns: false,
                thornExpiryTime: 0,
                originalSize: DEFAULT_SQUARE_SIZE,
                isBlue,
                lastPlayTime: 0
            };
        }
        
        // Initialize squares - positions updated to be within initial frame bounds
        let squares = [
            createSquare(100, 150, 0, '#3498db', 'blue.png', true),
            createSquare(500, 400, 2, '#e74c3c', 'red.png', false)
        ];
        
        // Powerups array
        let powerUps = [];
        
        // Function to check collision between square and power-up
        function checkPowerUpCollision(square, powerUp) {
            return square.x < powerUp.x + powerUp.size &&
                   square.x + square.size > powerUp.x &&
                   square.y < powerUp.y + powerUp.size &&
                   square.y + square.size > powerUp.y;
        }
        
        // Function to check collision between two squares
        function checkCollision(square1, square2) {
            return square1.x < square2.x + square2.size &&
                   square1.x + square1.size > square2.x &&
                   square1.y < square2.y + square2.size &&
                   square1.y + square1.size > square2.y;
        }

        // Determine which side of square2 was hit by square1
        function getCollisionSide(square1, square2) {
            const center1 = { x: square1.x + square1.size / 2, y: square1.y + square1.size / 2 };
            const center2 = { x: square2.x + square2.size / 2, y: square2.y + square2.size / 2 };
            
            const dx = center1.x - center2.x;
            const dy = center1.y - center2.y;
            
            if (Math.abs(dx) > Math.abs(dy)) {
                return dx > 0 ? "right" : "left";
            } else {
                return dy > 0 ? "bottom" : "top";
            }
        }

        // Function to separate squares after collision
        function separateSquares(square1, square2) {
            const dx = (square2.x + square2.size/2) - (square1.x + square1.size/2);
            const dy = (square2.y + square2.size/2) - (square1.y + square1.size/2);
            const distance = Math.sqrt(dx*dx + dy*dy);
            
            if (distance < (square1.size + square2.size)/2) {
                const pushDistance = ((square1.size + square2.size)/2 - distance) / 2;
                const pushX = (dx / distance) * pushDistance;
                const pushY = (dy / distance) * pushDistance;
                
                square1.x -= pushX;
                square1.y -= pushY;
                square2.x += pushX;
                square2.y += pushY;
            }
        }

        // Function to handle collision between two squares with reflective physics
        async function handleCollision(square1, square2) {
            const side1 = getCollisionSide(square1, square2);
            const side2 = getCollisionSide(square2, square1);
            
            if (side1 === "left" || side1 === "right") {
                square1.vx *= -1;
                
                if (square1.vy > 0) {
                    square1.direction = square1.vx > 0 ? 0 : 1;
                } else {
                    square1.direction = square1.vx > 0 ? 3 : 2;
                }
            } else {
                square1.vy *= -1;
                
                if (square1.vx > 0) {
                    square1.direction = square1.vy > 0 ? 0 : 3;
                } else {
                    square1.direction = square1.vy > 0 ? 1 : 2;
                }
            }
            
            if (side2 === "left" || side2 === "right") {
                square2.vx *= -1;
                
                if (square2.vy > 0) {
                    square2.direction = square2.vx > 0 ? 0 : 1;
                } else {
                    square2.direction = square2.vx > 0 ? 3 : 2;
                }
            } else {
                square2.vy *= -1;
                
                if (square2.vx > 0) {
                    square2.direction = square2.vy > 0 ? 0 : 3;
                } else {
                    square2.direction = square2.vy > 0 ? 1 : 2;
                }
            }
            
            // Separate squares to prevent sticking
            separateSquares(square1, square2);
            
            // Play collision sound for both squares
            await playSquareSound(square1);
            await playSquareSound(square2);
            
            // Check if damage should be dealt
            let damageDealt = false;
            let damagedSquare = null;
            
            if (square1.hasThorns && !square2.hasThorns) {
                square2.size = Math.max(0, square2.size - 30);
                squares.forEach(sq => sq.hasThorns = false);
                damageDealt = true;
                damagedSquare = square2;
                await playSound('hit');
            } else if (square2.hasThorns && !square1.hasThorns) {
                square1.size = Math.max(0, square1.size - 30);
                squares.forEach(sq => sq.hasThorns = false);
                damageDealt = true;
                damagedSquare = square1;
                await playSound('hit');
            }
            
            // Create particle effect if damage was dealt
            if (damageDealt && damagedSquare) {
                const centerX = damagedSquare.x + damagedSquare.size / 2;
                const centerY = damagedSquare.y + damagedSquare.size / 2;
                
                if (damagedSquare.size <= 30) {
                    createMultiColorExplosion(centerX, centerY);
                    damagedSquare.size = 0; // Hide the square
                } else {
                    if (damagedSquare.isBlue) {
                        blueParticles.createExplosion(centerX, centerY);
                    } else {
                        redParticles.createExplosion(centerX, centerY);
                    }
                }
            }
        }
        
        // Function to draw thorns around a square
        function drawThorns(square) {
            const size = square.size;
            const thornSize = size / 16;
            
            ctx.fillStyle = square.isBlue ? blueThornColor : redThornColor;
            
            // Top side
            for (let i = 0; i < size; i += thornSize * 2) {
                ctx.beginPath();
                ctx.moveTo(square.x + i, square.y);
                ctx.lineTo(square.x + i + thornSize, square.y - thornSize);
                ctx.lineTo(square.x + i + thornSize * 2, square.y);
                ctx.closePath();
                ctx.fill();
            }
            
            // Bottom side
            for (let i = 0; i < size; i += thornSize * 2) {
                ctx.beginPath();
                ctx.moveTo(square.x + i, square.y + size);
                ctx.lineTo(square.x + i + thornSize, square.y + size + thornSize);
                ctx.lineTo(square.x + i + thornSize * 2, square.y + size);
                ctx.closePath();
                ctx.fill();
            }
            
            // Left side
            for (let i = 0; i < size; i += thornSize * 2) {
                ctx.beginPath();
                ctx.moveTo(square.x, square.y + i);
                ctx.lineTo(square.x - thornSize, square.y + i + thornSize);
                ctx.lineTo(square.x, square.y + i + thornSize * 2);
                ctx.closePath();
                ctx.fill();
            }
            
            // Right side
            for (let i = 0; i < size; i += thornSize * 2) {
                ctx.beginPath();
                ctx.moveTo(square.x + size, square.y + i);
                ctx.lineTo(square.x + size + thornSize, square.y + i + thornSize);
                ctx.lineTo(square.x + size, square.y + i + thornSize * 2);
                ctx.closePath();
                ctx.fill();
            }
        }

        // Function to update the simulation
        function update() {
            if (isPaused) return;
            
            const currentTime = Date.now();
            
            // Clear canvas with the selected background color
            ctx.fillStyle = canvasBackgroundColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw the collision frame (visible in both gameplay and recordings)
            drawCollisionFrame();
            
            // Update and draw power-ups
            for (let i = powerUps.length - 1; i >= 0; i--) {
                const powerUp = powerUps[i];
                
                if (powerUp.img.complete && powerUp.img.naturalWidth > 0) {
                    ctx.drawImage(powerUp.img, powerUp.x, powerUp.y, powerUp.size, powerUp.size);
                } else {
                    // Fallback for power-up images
                    ctx.fillStyle = powerUp.type === 'knife' ? '#333' : '#2ecc71';
                    ctx.fillRect(powerUp.x, powerUp.y, powerUp.size, powerUp.size);
                }
                
                let powerUpCollected = false;
                for (let j = 0; j < squares.length; j++) {
                    const square = squares[j];
                    
                    if (square.size > 0 && checkPowerUpCollision(square, powerUp)) {
                        if (powerUp.type === 'knife') {
                            squares.forEach(sq => sq.hasThorns = false);
                            
                            square.hasThorns = true;
                            square.thornExpiryTime = currentTime + THORN_DURATION;
                            
                            playSound('knife');
                        } else if (powerUp.type === 'heal') {
                            square.size = Math.min(120, square.size + 30);
                            
                            playSound('heal');
                        }
                        
                        powerUpCollected = true;
                        break;
                    }
                }
                
                if (powerUpCollected) {
                    powerUps.splice(i, 1);
                }
            }
            
            // Update and draw squares
            for (let i = 0; i < squares.length; i++) {
                const square = squares[i];
                
                // Skip if square is "dead" (size 0)
                if (square.size <= 0) continue;
                
                // Check if thorns effect has expired
                if (square.hasThorns && currentTime > square.thornExpiryTime) {
                    square.hasThorns = false;
                }
                
                // Update position
                square.x += square.vx * speedMultiplier;
                square.y += square.vy * speedMultiplier;
                
                // Check collision with frame boundaries
                if (square.x <= frameBounds.left || square.x + square.size >= frameBounds.right) {
                    // Reflect horizontally
                    square.vx *= -1;
                    
                    // Play sound
                    playSquareSound(square);
                    
                    // Shrink frame when square hits boundary
                    shrinkFrame();
                    
                    // Update direction
                    if (square.direction === 0) square.direction = 1;
                    else if (square.direction === 1) square.direction = 0;
                    else if (square.direction === 2) square.direction = 3;
                    else if (square.direction === 3) square.direction = 2;
                    
                    // Keep inside frame bounds
                    if (square.x <= frameBounds.left) square.x = frameBounds.left;
                    if (square.x + square.size >= frameBounds.right) square.x = frameBounds.right - square.size;
                }
                
                if (square.y <= frameBounds.top || square.y + square.size >= frameBounds.bottom) {
                    // Reflect vertically
                    square.vy *= -1;
                    
                    // Play sound
                    playSquareSound(square);
                    
                    // Shrink frame when square hits boundary
                    shrinkFrame();
                    
                    // Update direction
                    if (square.direction === 0) square.direction = 3;
                    else if (square.direction === 1) square.direction = 2;
                    else if (square.direction === 2) square.direction = 1;
                    else if (square.direction === 3) square.direction = 0;
                    
                    // Keep inside frame bounds
                    if (square.y <= frameBounds.top) square.y = frameBounds.top;
                    if (square.y + square.size >= frameBounds.bottom) square.y = frameBounds.bottom - square.size;
                }
                
                // Draw the square with its image or fallback color
                if (square.img.complete && square.img.naturalWidth > 0) {
                    ctx.drawImage(square.img, square.x, square.y, square.size, square.size);
                } else {
                    // Fallback to colored rectangles
                    ctx.fillStyle = square.isBlue ? BLUE_SQUARE_COLOR : RED_SQUARE_COLOR;
                    ctx.fillRect(square.x, square.y, square.size, square.size);
                }
                
                // Draw stroke around the square
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.strokeRect(square.x, square.y, square.size, square.size);
                
                // Draw thorns if square has them
                if (square.hasThorns) {
                    drawThorns(square);
                }
            }
            
            // Update health based on square sizes
            redSquareHealth = calculateHealth(squares[1].size);
            blueSquareHealth = calculateHealth(squares[0].size);
            
            // Update health bar displays
            updateHealthBar(redHealthBar, redSquareHealth, 6, redHealthColor);
            updateHealthBar(blueHealthBar, blueSquareHealth, 6, blueHealthColor);
            
            // Check collision between squares
            if (squares[0].size > 0 && squares[1].size > 0 && checkCollision(squares[0], squares[1])) {
                handleCollision(squares[0], squares[1]);
            }
            
            // Update and draw particles
            redParticles.animate();
            blueParticles.animate();
        }

        // Animation loop
        function animate() {
            update();
            animationId = requestAnimationFrame(animate);
        }

        // Stop animation
        function stopAnimation() {
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
        }

        // Image loading handler
        function imageLoaded() {
            loadedImages++;
            if (loadedImages === totalImages) {
                console.log("All images loaded, starting game");
                startGame();
            }
        }

        // Set up image loading with error handlers
        redSquareImg.onload = imageLoaded;
        redSquareImg.onerror = function() {
            console.log("Red square image failed to load");
            redSquareImgLoaded = false;
            imageLoaded();
        };
        
        blueSquareImg.onload = imageLoaded;
        blueSquareImg.onerror = function() {
            console.log("Blue square image failed to load");
            blueSquareImgLoaded = false;
            imageLoaded();
        };
        
        knifeImg.onload = imageLoaded;
        knifeImg.onerror = function() {
            console.log("Knife image failed to load");
            knifeImgLoaded = false;
            imageLoaded();
        };
        
        healImg.onload = imageLoaded;
        healImg.onerror = function() {
            console.log("Heal image failed to load");
            healImgLoaded = false;
            imageLoaded();
        };

        // Start the game when all images are loaded
        function startGame() {
            if (loadedImages === totalImages) {
                animate();
                // Set up power-up spawning
                knifeSpawnInterval = setInterval(spawnKnifePowerUp, KNIFE_SPAWN_INTERVAL);
                healSpawnInterval = setInterval(spawnHealPowerUp, HEAL_SPAWN_INTERVAL);
            }
        }

        // Initialize health bars with default colors
        updateHealthBar(redHealthBar, redSquareHealth, 4, redHealthColor);
        updateHealthBar(blueHealthBar, blueSquareHealth, 4, blueHealthColor);
        
        // Clean up when page unloads
        window.addEventListener('beforeunload', function() {
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
            }
            stopAnimation();
            if (knifeSpawnInterval) clearInterval(knifeSpawnInterval);
            if (healSpawnInterval) clearInterval(healSpawnInterval);
        });
        
        // Event listeners for buttons
        resetBtn.addEventListener('click', function() {
            // Clear existing intervals
            if (knifeSpawnInterval) clearInterval(knifeSpawnInterval);
            if (healSpawnInterval) clearInterval(healSpawnInterval);
            
            squares = [
                createSquare(100, 150, 0, '#3498db', 'blue.png', true),
                createSquare(500, 400, 2, '#e74c3c', 'red.png', false)
            ];
            powerUps = [];
            speedMultiplier = 1;
            speedBtn.textContent = 'Speed: 1x';
            isPaused = false;
            pauseBtn.textContent = 'Pause';
            
            // Reset health
            redSquareHealth = 4;
            blueSquareHealth = 4;
            
            // Reset frame
            resetFrame();
            
            // Clear particles
            redParticles.clear();
            blueParticles.clear();
            
            // Restart power-up spawning
            knifeSpawnInterval = setInterval(spawnKnifePowerUp, KNIFE_SPAWN_INTERVAL);
            healSpawnInterval = setInterval(spawnHealPowerUp, HEAL_SPAWN_INTERVAL);
        });

        pauseBtn.addEventListener('click', function() {
            isPaused = !isPaused;
            pauseBtn.textContent = isPaused ? 'Resume' : 'Pause';
        });

        speedBtn.addEventListener('click', function() {
            speedMultiplier = (speedMultiplier >= 3) ? 1 : speedMultiplier + 0.5;
            this.textContent = `Speed: ${speedMultiplier}x`;
        });
        
        // Thorn color input event listeners
        redThornColorInput.addEventListener('input', function() {
            if (isValidHexColor(this.value)) {
                redThornColor = this.value;
            }
        });
        
        blueThornColorInput.addEventListener('input', function() {
            if (isValidHexColor(this.value)) {
                blueThornColor = this.value;
            }
        });
        
        // Health bar color input event listeners
        redHealthColorInput.addEventListener('input', function() {
            if (isValidHexColor(this.value)) {
                redHealthColor = this.value;
                redParticles.options.color = this.value;
            }
        });
        
        blueHealthColorInput.addEventListener('input', function() {
            if (isValidHexColor(this.value)) {
                blueHealthColor = this.value;
                blueParticles.options.color = this.value;
            }
        });
    </script>
</body>
</html>
